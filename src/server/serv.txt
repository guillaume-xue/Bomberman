// dans main server

int main() {
    int server_socket;
    struct sockaddr_in6 server_addr, client_addr;
    socklen_t addr_len = sizeof(client_addr);
    struct pollfd fds[MAX_CLIENTS];
    int nfds = 1; 
    int timeout = -1; // temps d'attente à voir après 

    // Initialisation
    for (int i = 0; i < MAX_CLIENTS; ++i) {
        fds[i].fd = -1;
        fds[i].events = POLLIN;
    }

    server_socket = socket(AF_INET6, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror("La création de la socket a échoué");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin6_family = AF_INET6;
    server_addr.sin6_port = htons(TCP_PORT);
    inet_pton(AF_INET6, "::1", &server_addr.sin6_addr);

    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("La liaison a échoué");
        close(server_socket);
        exit(EXIT_FAILURE);
    }

    if (listen(server_socket, 10) < 0) {
        perror("Écoute des connexions a échoué");
        close(server_socket);
        exit(EXIT_FAILURE);
    }

    init_mutex();

    printf("Serveur démarré, en attente de connexions...\n\n");

    fds[0].fd = server_socket;
    fds[0].events = POLLIN;

    while (1) {
        int poll_count = poll(fds, nfds, timeout);

        if (poll_count == -1) {
            perror("poll a échoué");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < nfds; ++i) {
            if (fds[i].revents & POLLIN) {
                if (fds[i].fd == server_socket) {
                    int client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_len);
                    if (client_socket == -1) {
                        perror("accept a échoué");
                    } else {
                        printf("Ohhh, un client a rejoint le serveur\n");

                       
                        for (int j = 1; j < MAX_CLIENTS; ++j) {
                            if (fds[j].fd == -1) {
                                fds[j].fd = client_socket;
                                fds[j].events = POLLIN;
                                if (j >= nfds) {
                                    nfds = j + 1;
                                }
                                break;
                            }
                        }
                    }
                } else {
                    int client_socket = fds[i].fd;
                    handle_client_poll(client_socket);

                    close(client_socket);
                    fds[i].fd = -1;

                    if (i == nfds - 1) {
                        while (nfds > 1 && fds[nfds - 1].fd == -1) {
                            --nfds;
                        }
                    }
                }
            }
        }
    }

    close(server_socket);
    return 0;
}

// rajout de handle_client_poll dans le server 

// Version poll
void handle_client_poll(int client_socket) {
    EnteteMessage received_message;
    memset(&received_message, 0, sizeof(EnteteMessage));

    if (recv(client_socket, &received_message, sizeof(EnteteMessage), 0) < 0) {
        perror("La réception du message a échoué");
        return;
    }

    int index_partie = join_or_create(client_socket, received_message.CODEREQ);

    GameMessage client_ready;
    memset(&client_ready, 0, sizeof(GameMessage));

    if (recv(client_socket, &client_ready, sizeof(GameMessage), 0) < 0) {
        perror("La réception du message a échoué");
        return;
    }

    char buf[SIZE_MSG];
    memset(buf, 0, sizeof(buf));

    if (client_ready.EQ == -1) {
        snprintf(buf, SIZE_MSG,
                 "\nLe client devient : %sJoueur n.%d%s et rejoint la partie n.%d "
                 "en mode : SOLO (1v3).",
                 id_to_color(client_ready.ID), client_ready.ID, "\33[0m",
                 index_partie);
    } else {
        snprintf(buf, SIZE_MSG,
                 "\nLe client devient : %sJoueur n.%d%s dans l'équipe %d et "
                 "rejoint la partie n.%d en mode : MULTIJOUEUR (2v2).",
                 id_to_color(client_ready.ID), client_ready.ID, "\33[0m",
                 client_ready.EQ, index_partie);
    }

    //printf("%s\n", buf);

    pthread_mutex_lock(&mutex_parties[index_partie]);
    printf("Il reste %d places dans la partie n.%d %s\n",
           MAX_CLIENTS - parties[index_partie].nb_joueurs, index_partie,
           (MAX_CLIENTS - parties[index_partie].nb_joueurs == 0)
               ? "\n\033[31m\nNous sommes au complet, la partie peut commencer "
                 "!!\033[0m\n"
               : "\n");

    if (MAX_CLIENTS - parties[index_partie].nb_joueurs == 0) {
        pthread_t thread_partie;
        int *x = malloc(sizeof(int));
        if(x == NULL) {
            perror("Erreur début de partie");
            return;
        }
        *x = index_partie;
        pthread_create(&thread_partie, NULL, handle_partie, x);
        pthread_join(thread_partie, NULL);
    } else {
        pthread_mutex_unlock(&mutex_parties[index_partie]);
    }
}